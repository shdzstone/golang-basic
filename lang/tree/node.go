package tree

import (
	"fmt"
)

/**
1.面向对象
* go语言只支持封装，不支持继承和多态：继承和多态所做的事情，可以用接口来做，即面向接口编程
* go语言只有struct，没有class
* 定义：type name struct{}
* 不论是地址还是结构本身，一律使用"."来访问成员
* go中的对象没有构造函数，可以创建工厂函数

2、结构对象存储
* 结构体创建后是位于堆上还是位于栈上？不需要知道
* 编译器由运行环境决定变量存储位置：若没有取地址并返回给调用者，则在栈上分配内存；若取了地址并返回给调用者，则在堆上分配内存并参与垃圾回收机制，当调用者不用指针后，则垃圾回收器回收该内存
* go语言函数体内的局部变量不一定在函数体结束就销毁该局部变量

3、结构体函数
* 显式定义和命名方法接收者
* 方法格式：func [(接收者/指针)] func_name(var_name var_type) return_type {}
* 结构体方法和普通函数实质上一样，只不过方法比函数多一个接收者参数
* 只有使用指针才可以改变结构内容
* go语言中，nil指针也可以调用成员，但不能访问其具体的值，和其它语言中的null不一样
* 空指针值传递并调用其成员函数或赋值时，会报panic，须分配内存后再进行值传递调用成员

4. 值接收者和指针指收者
* 要改变内容必须使用指针接收者
* 结构过大也考虑使用指针接收者
* 一致性：如果有指针接收者，最好都是指针接收者
* 值接收者是go语言特有，其它语言基本上都有this之类的指针接收者
* 值/指针接收者均可接收值/指针

*/

type Node struct {
	Value       int
	Left, Right *Node
}

//结构体函数
//函数格式：func [(接收者)] func_name(var_name var_type) return_type {}
func (node Node) Print() {
	fmt.Print(node.Value, " ")
}

//函数接收者也是值传递
//要改变接收者的值，可以和普通函数一样，传指针即可
//go语言中，接收者无论是普通对象还是指针，访问成员时，都可以使用"."操作符，而不是"->"
//函数接收者若是值传递，则把调用者拷贝一份并赋值给接收参数；
//若是指针，则把指针的地址拷贝一份并赋值给接收参数，接收参数可以直接通过指针修改调用者的值
//接收者为nil时，也可以调用成功，但不能访问其成员的值
//是否判空要看具体使用场景，没必要必须判空
func (node *Node) SetValue(value int) {
	if node == nil {
		fmt.Println("Setting Value to nil " + "node. Ignored.")
		return
	}
	node.Value = value
}

//factory函数
func CreateNode(value int) *Node {
	//go语言允许返回的局部变量的地址给调用者
	return &Node{Value: value}
}
